{
  "published": true,
  "date": "2020-04-02T00:00:00.000Z",
  "title": "How to detect when an object changes in JavaScript",
  "slug": "js-object-changes",
  "description": "You can use JavaScript's Proxy in order to run some code every time an object changes. Proxies allow you to define custom ways that properties on an object should be read and set.  Within the \"set\" method, you can run any code you want. ",
  "body": "You can use a JavaScript feature called a [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) to define how properties of an object are read and set. \n\nThe `Proxy` takes a target (the object that the `Proxy` is wrapping), and a handler (which defines how the `Proxy` should act). \n\nHere's an example: \n\n```javascript\nconst sourceObject = {}\n\nconst handler = {\n  get: (target, key) => {\n    if(typeof target[key] === \"object\" && target[key] !== null) {\n      return new Proxy(target[key], handler)\n    }\n\n    return target[key]\n  },\n  set: (target, prop, value) => {\n      target[prop] = value\n      console.log(\"A change was made!\")\n    return true\n  }\n}\n\nconst object = new Proxy(sourceObject, handler)\n```\n\nIn the `get` method of the `Proxy`'s handler, we check whether what we're returning is of type `object` (an array, object, etc). If it is, we wrap it in a new `Proxy` using the same handler as itself.\n\nThis is to ensure that all changes go through this `Proxy`, and the `console.log` statement runs for every change. \n\nIf we didn't wrap objects returned from the `get` method in another `Proxy`, this kind of \"deeper\" change would not result in a `console.log`: \n\n```javascript\n// continuing example from above\n\nobject.list = [] // \"A change was made!\"\nobject.list.push(\"foo\") // no console.log statement\n```"
}